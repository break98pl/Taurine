//
//  krw.m
//  kfd
//
//  Created by Seo Hyun-gyu on 2023/08/10.
//

#import <Foundation/Foundation.h>
#include "KernelRwWrapper.h"
#import "libkfd.h"

static uint64_t _kfd = 0;
static uint64_t _self_task = 0;
static uint64_t _self_proc = 0;
static uint64_t _kslide = 0;

static uint64_t kread64(uint64_t where) {
    uint64_t out;
    kread_(_kfd, where, &out, sizeof(uint64_t));
    return out;
}

static void kwrite64(uint64_t where, uint64_t what) {
    u64 _buf[1] = {};
    _buf[0] = what;
    kwrite_((u64)(_kfd), &_buf, where, sizeof(u64));
}

static uint64_t get_selftask(void) {
    return _self_task;
}

static uint64_t get_selfproc(void) {
    return _self_proc;
}

static uint64_t get_kslide(void) {
    return _kslide;
}

static void set_selftask(void) {
    _self_task = ((struct kfd*)_kfd)->info.kernel.current_task;
}

static void set_selfproc(void) {
    _self_proc = ((struct kfd*)_kfd)->info.kernel.current_proc;
}

static void set_kslide(void) {
    _kslide = ((struct kfd*)_kfd)->info.kernel.kernel_slide;
}

static void do_kclose(void)
{
    kclose(_kfd);
}

static uint8_t kread8(uint64_t where) {
    uint8_t out;
    kread_(_kfd, where, &out, sizeof(uint8_t));
    return out;
}
static uint32_t kread16(uint64_t where) {
    uint16_t out;
    kread_(_kfd, where, &out, sizeof(uint16_t));
    return out;
}
static uint32_t kread32(uint64_t where) {
    uint32_t out;
    kread_(_kfd, where, &out, sizeof(uint32_t));
    return out;
}

static void kwrite8(uint64_t where, uint8_t what) {
    uint8_t _buf[8] = {};
    _buf[0] = what;
    _buf[1] = kread8(where+1);
    _buf[2] = kread8(where+2);
    _buf[3] = kread8(where+3);
    _buf[4] = kread8(where+4);
    _buf[5] = kread8(where+5);
    _buf[6] = kread8(where+6);
    _buf[7] = kread8(where+7);
    kwrite_((u64)(_kfd), &_buf, where, sizeof(u64));
}

static void kwrite16(uint64_t where, uint16_t what) {
    u16 _buf[4] = {};
    _buf[0] = what;
    _buf[1] = kread16(where+2);
    _buf[2] = kread16(where+4);
    _buf[3] = kread16(where+6);
    kwrite_((u64)(_kfd), &_buf, where, sizeof(u64));
}

static void kwrite32(uint64_t where, uint32_t what) {
    u32 _buf[2] = {};
    _buf[0] = what;
    _buf[1] = kread32(where+4);
    kwrite_((u64)(_kfd), &_buf, where, sizeof(u64));
}

uint64_t funVnode(uint64_t proc, char* filename) {
    //16.1.2 offsets
    uint32_t off_p_pfd = 0xf8;
    uint32_t off_fd_ofiles = off_fd_ofiles = 0x0;
    uint32_t off_fp_fglob = 0x10;
    uint32_t off_fg_data = 0x38;
    uint32_t off_vnode_iocount = 0x64;
    uint32_t off_vnode_usecount = 0x60;
    uint32_t off_vnode_vflags = 0x54;
    int file_index = open(filename, O_RDONLY);
    printf("file_index: 0x%llx\n", file_index);
    if (file_index == -1) {
        printf("File not exist\n");
        return -1;
    }
    //get vnode
    uint64_t filedesc = kread64(proc + off_p_pfd);
    printf("filedesc: 0x%llx\n", filedesc);
    uint64_t fileproc = kread64(filedesc + off_fd_ofiles);
    printf("fileproc: 0x%llx\n", fileproc);
//    printf("openedfile: 0x%llx\n", filedesc + (8 * file_index));
    uint64_t openedfile = kread64(fileproc + (8 * file_index));
    printf("openedfile: 0x%llx\n", openedfile);
    uint64_t fileglob = kread64(openedfile + off_fp_fglob);
    printf("fileglob: 0x%llx\n", fileglob);
    uint64_t vnode = kread64(fileglob + off_fg_data);
    printf("vnode: 0x%llx\n", vnode);
    //vnode_ref, vnode_get
    uint32_t usecount = kread32(vnode + off_vnode_usecount);
    uint32_t iocount = kread32(vnode + off_vnode_iocount);
    printf("usecount: %d, iocount: %d\n", usecount, iocount);
    kwrite32(vnode + off_vnode_usecount, usecount + 1);
    kwrite32(vnode + off_vnode_iocount, iocount + 1);
#define VISSHADOW 0x008000
    //hide file
    uint32_t v_flags = kread32(vnode + off_vnode_vflags);
    printf("v_flags: 0x%x\n", v_flags);
    kwrite32(vnode + off_vnode_vflags, (v_flags | VISSHADOW));

    //exist test (should not be exist
    printf("[i] is File exist?: %d\n", access(filename, F_OK));
    close(file_index);

    return vnode;
}

uint64_t do_restorevnode(uint64_t puaf_pages, uint64_t puaf_method, uint64_t kread_method, uint64_t kwrite_method)
{
    _kfd = kopen(puaf_pages, puaf_method, kread_method, kwrite_method);//kopen_intermediate(puaf_pages, puaf_method, kread_method, kwrite_method);
    set_selfproc();
    set_selftask();
    set_kslide();
    our_proc_kAddr = get_selfproc();
    usleep(10000);
    initKernRw(get_selftask(), kread64, kwrite64);
    printf("isKernRwReady: %d\n", isKernRwReady());
    if(isKernRwReady()) {
        usleep(10000);
        //
        uint32_t off_vnode_iocount = 0x64;
        uint32_t off_vnode_usecount = 0x60;
        uint32_t off_vnode_vflags = 0x54;
#define VISSHADOW 0x008000
        const char *vnodeMemPath =
              [NSString stringWithFormat:@"/var/mobile/saveVnode.txt"].UTF8String;
        if (access(vnodeMemPath, F_OK) == 0) {
            FILE *fp = fopen(vnodeMemPath, "r");
            uint64_t savedVnode;
            int i = 0;
            while (!feof(fp)) {
              if (fscanf(fp, "0x%" PRIX64 "\n", &savedVnode) == 1) {
                  uint32_t v_flags = kread32(savedVnode + off_vnode_vflags);
                      kwrite32(savedVnode + off_vnode_vflags, (v_flags &= ~VISSHADOW));
              }
              i++;
            }
            remove(vnodeMemPath);
          }
        //
        do_kclose();
    }
    return _kfd;
}

uint64_t do_vnodebypass(uint64_t puaf_pages, uint64_t puaf_method, uint64_t kread_method, uint64_t kwrite_method)
{
    _kfd = kopen(puaf_pages, puaf_method, kread_method, kwrite_method);//kopen_intermediate(puaf_pages, puaf_method, kread_method, kwrite_method);
    set_selfproc();
    set_selftask();
    set_kslide();
    our_proc_kAddr = get_selfproc();
    usleep(10000);
    initKernRw(get_selftask(), kread64, kwrite64);
    printf("isKernRwReady: %d\n", isKernRwReady());
    if(isKernRwReady()) {
        usleep(10000);
        //
        const char *vnodeMemPath =
              [NSString stringWithFormat:@"/var/mobile/saveVnode.txt"].UTF8String;
        if (access(vnodeMemPath, F_OK) == 0) {
          printf("Already exist /tmp/vnodeMem.txt, Please vnode recovery first!\n");
          return 222;
        }
        FILE *fp = fopen(vnodeMemPath, "w");
        NSArray *hidePathList = hidePathList = [NSArray
             arrayWithContentsOfFile:[NSString stringWithFormat:@"/var/mobile/hidePathList.plist"]];
        if (hidePathList == nil) goto exit;
        int hideCount = (int)[hidePathList count];
        for (int i = 0; i < hideCount; i++) {
            const char *hidePath = [[hidePathList objectAtIndex:i] UTF8String];
            uint64_t savedVnode = funVnode(_self_proc, hidePath);
            fprintf(fp, "0x%" PRIX64 "\n", savedVnode);
        }
        fclose(fp);
        //
        do_kclose();
    }
    return _kfd;
    exit:
        do_kclose();
        printf("hidePathList.plist is broken, please reinstall vnodebypass!\n");
        exit(111);
}

uint64_t do_kopen(uint64_t puaf_pages, uint64_t puaf_method, uint64_t kread_method, uint64_t kwrite_method)
{
    _kfd = kopen(puaf_pages, puaf_method, kread_method, kwrite_method);//kopen_intermediate(puaf_pages, puaf_method, kread_method, kwrite_method);
    set_selfproc();
    set_selftask();
    set_kslide();
    our_proc_kAddr = get_selfproc();
    usleep(10000);
    initKernRw(get_selftask(), kread64, kwrite64);
    printf("isKernRwReady: %d\n", isKernRwReady());
    if(isKernRwReady()) {
        usleep(10000);
        do_kclose();
    }
    return _kfd;
}

static void do_kread(uint64_t kaddr, void* uaddr, uint64_t size)
{
    kread_(_kfd, kaddr, uaddr, size);
}

static void do_kwrite(void* uaddr, uint64_t kaddr, uint64_t size)
{
    kwrite_(_kfd, uaddr, kaddr, size);
}

static uint64_t get_kernproc(void) {
    return ((struct kfd*)_kfd)->info.kernel.kernel_proc;
}

static void kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    uint64_t endAddr = kaddr + size;
    uint32_t outputOffset = 0;
    unsigned char* outputBytes = (unsigned char*)output;
    
    for(uint64_t curAddr = kaddr; curAddr < endAddr; curAddr += 4)
    {
        uint32_t k = kread32(curAddr);

        unsigned char* kb = (unsigned char*)&k;
        for(int i = 0; i < 4; i++)
        {
            if(outputOffset == size) break;
            outputBytes[outputOffset] = kb[i];
            outputOffset++;
        }
        if(outputOffset == size) break;
    }
}
